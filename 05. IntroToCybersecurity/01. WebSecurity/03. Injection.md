# Injection

## Shell Command
* Imagine an application that needs to run the 'date' system command
* The code for this system command resides in ```/user/bin/date```
* **system()**: an operation that exists in many languages that is used to execute a program
* **execve()**: a system call that launches a process
---

### Example
```system('date')```<br>
```execve("/bin/sh", ["sh", "-c", "date"], {...})```<br>
```execve("/usr/bin/date", ["date"], {...})```<br>

---
* Here, we are calling ```system()``` on the ```date``` program
* The first execve() command launches a shell, parses the argument (```date```), and executes it in the shell
  * **Shell**: job is to parse your statement and convert it into program invocations
  * **-c**: flag that specifies the shell to parse the argument and run it, as if the user typed it into the terminal and ran it himself
* The second execve() command attempts to find the location of the ```date``` program within the shell

## Environment Variables
* We can specify the timezone for the date
* We put environment variables before the program we want to run in order to do this
---

### Example: UTC
```system("TZ=UTC date")```<br>
```execve("/bin/sh", ["sh", "-c", "TZ=UTC date"], {...})```<br>
```execve("/usr/bin/date", ["date"], {"TZ": "UTC"})```<br>

### Example: MST
```system("TZ=MST date")```<br>
```execve("/bin/sh", ["sh", "-c", "TZ=MST date"], {...})```<br>
```execve("/usr/bin/date", ["date"], {"TZ": "MST"})```<br>

---
* Useful if we want different users from different timezones accessing the program
* We can also take a user response and inject that user-specified timezone into the website

## Command Injection: Part 1
* Issue: all we are doing is concatenating ```TZ=<userInput>+date``` and just pushing it off to the shell to execute
* **Backtick Operator (``` ` ```)**: if you specify another system program as an environment variable in between two backticks, the shell executes that program and uses the output of that command as the new timezone

 ---

### Example
```system("TZ=`whoami` date")``` <br>
```execve("/bin/sh", ["sh", "-c", "TZ=`whoami` date"], {...})``` <br>
```execve("/usr/bin/whoami", ["whoami"], {...})``` <br>
```execve("/usr/bin/date", ["date"], {"TZ": "root"})```

 ---
* The shell tries to run the ```/user/bin/whoami``` program to subsitute the output of the ```whoami``` command in for the ```TZ``` env variable
* Once the shell receives the output of ```whoami``` (in our case, it is *root*), it is passed into the ```TZ``` environment variable
* Now ```/user/bin/date``` is ran with the timezone of ```root```

## Command Injection: Part 2
* We now understand that we have a very aggressive level of control over the launching shell if we have user input
* We can start out user input with a semicolon (```;```)
---

### Example
```system("TZ=`whoami` date")```<br>
```execve("/bin/sh", ["sh", "-c", "TZ=`whoami` date"], {...})```<br>
```execve("/usr/bin/whoami", ["whoami"], {...})```<br>
```execve("/usr/bin/date", ["date"], {"TZ": "root"})```<br>

---
* The semicolon specifies that we are passing in the empty string into the ```TZ``` environment variable
* After we end that shell statement, we move onto the next line in the shell to begin a new shell statement
* In this newline, we run the ```whoami``` command
* At the end of the statement, there is a space and a pound (```#```) symbol that follows
  * This pound (```#```) symbol comments out (ignores) the rest of the command, which in our case is ```date```
  * Thus, instead of executing ```whoami date```, we execute ```whoami```
